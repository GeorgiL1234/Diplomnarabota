# ДИПЛОМНА РАБОТА

## Web Shop – Платформа за обяви и продажби

---

**ОБЩИ ИЗИСКВАНИЯ КЪМ ОФОРМЛЕНИЕТО (съгласно точка 1.1–1.5):**  
Обем: минимум 40 страници форматиран текст – 30 реда × 60 знака (1800 знака/страница); интервал double или 1,5; шрифт 12–14 pt. Номерация: първата цифра – номер на главата, втората – пореден номер (напр. Фигура 2.1, Таблица 3.2). Литературата се цитира в текста [1], [2], … Заглавията на главите са смислен текст, ориентиран към структурата и разработваната система.

---

**Титулна страница** *(по образец на учебното заведение)*

*[Тук се поставя официалната титулна страница по образец]*

---

**Задание за дипломна работа** *(по образец)*

*[Тук се поставя заданието за дипломната работа по образец]*

---

**Отзив на научния ръководител и предложение за рецензент** *(по образец)*

*[Тук се поставя отзивът и предложението по образец]*

---

# УВОД

Онлайн търговията и платформите за обяви са неразделна част от съвременния цифров живот. През последните години бързо нараства броят на уеб приложенията, които свързват продавачи и купувачи, позволявайки търговия на разстояние с минимални разходи за влизане на пазара. Според статистиката на НСИ [1] електронната търговия в България нараства с над 15% годишно, като все по-голям дял от транзакциите се осъществяват чрез платформи за обяви и C2C (consumer-to-consumer) продажби между физически лица. Подобни системи са OLX, Bazos, Facebook Marketplace и множество локални платформи за обяви, които всеки ден обработват хиляди обяви и транзакции.

Настоящата дипломна работа представя разработката на Web Shop – пълнофункционална уеб платформа за обяви и продажби. Системата позволява на потребителите да регистрират се с email и парола, създават обяви с снимки, комуникират чрез вградена система за съобщения между купувачи и продавачи, правят поръчки с избор на начин на плащане и доставка, добавят ревюта и оценки, и плащат за VIP статус на обявите, който ги поставя на по-видно място в списъка. Платформата поддържа три езика – български, английски и руски – и е разположена в облака (Vercel за frontend, Render.com за backend), което я прави достъпна от всяка точка на света без необходимост от локална инсталация.

Акцентът в разработката е поставен върху простотата на използването, бързото зареждане, съвместимостта с безплатни hosting платформи и обработката на типични проблеми като cold start при Render.com, timeout при бавни мрежи и потребителски feedback чрез цветни съобщения за успех и грешка. Системата е подходяща за образователни проекти, малки стартиращи бизнеси и демонстрация на модерни уеб технологии.

**Цели на дипломната работа:**

Първата цел е разработката на функционална уеб платформа за обяви с модерен потребителски интерфейс – интуитивна навигация, ясни форми, визуална обратна връзка при действия и отзивчив дизайн, работещ на различни размери екрани.

Втората цел е интеграция на система за плащания за VIP обяви – потребителите да могат да плащат 2€ за да поставят обявата си на първо място в списъка, с възможност за разширяване към реален платежен процесор (Stripe) в production.

Третата цел е осигуряване на многоезичност (български, английски, руски) и отзивчив дизайн – всички текстове да са преведени, потребителят да може да сменя езика от header, а интерфейсът да се адаптира към мобилни и десктоп устройства.

Четвъртата цел е пълно документиране на архитектурата, реализацията и използването на системата – от проучвателната част и избора на технологии до ръководство за потребителя и приложение с API документация.

**Задачи на дипломната работа:**

1. Проучване на съществуващи подобни системи (OLX, Bazos, Facebook Marketplace, e-commerce платформи) и развойни средства (React, Spring Boot, H2, Vercel, Render) – да се анализират предимствата и недостатъците и да се обоснове изборът на технологии.

2. Дефиниране на функционалните изисквания и аргументиран избор на езика за програмиране и софтуерните средства – да се опишат всички изисквания (ФИ-1 до ФИ-9) и да се обоснове защо са избрани React, TypeScript, Vite, Java, Spring Boot, H2, Stripe, Vercel и Render.

3. Проектиране на архитектурата (трислойна), алгоритмите (създаване на обява, VIP плащане, съобщения, поръчки) и структурата на базата данни – да се опишат таблиците, релациите и сценарият на уеб страницата.

4. Реализация на backend компонентите (контролери, сървиси, модели, репозитории) и frontend компонентите (страници, форми, API комуникация) – да се разработят всички функционалности със съответната обработка на грешки и edge cases.

5. Интеграция и тестване на системата – backend и frontend да работят заедно, да се тестват основните потоци (регистрация, създаване на обява, поръчка, съобщения) и да се разположи в облака.

6. Съставяне на ръководство за потребителя – да се опишат инсталацията, изискванията към конфигурацията, въвеждането и редактирането на информация, съхранението, архивирането и извеждането на справки, както и отстраняването на проблеми.

---

# ГЛАВА 1. ПРОУЧВАНЕ НА ПОДОБНИ СИСТЕМИ И РАЗВОЙНИ СРЕДСТВА ЗА WEB SHOP

## 1.1. Преглед на съществуващи подобни програмни системи

В тази секция се прави преглед на съществуващите платформи за обяви и e-commerce системи, за да се идентифицират общите функционалности, архитектурните решения и да се обоснове какво е подходящо за дипломен проект с ограничен срок и ресурси.

### 1.1.1. OLX и Bazos

OLX [2] е една от най-големите световни платформи за обяви, оперативна в над 40 държави, включително България. Системата предлага регистрация чрез email или социални мрежи (Facebook, Google), създаване на обяви с множество снимки (до 20 на обява), търсене и филтриране по категория, цена, локация и ключови думи, директна комуникация между потребителите чрез вграден чат. OLX използва платени „бустирани“ позиции – продавачите могат да платят за по-добра видимост на обявата. Bazos е популярна българска платформа с подобни функции – безплатни обяви, платени „бустирани“ позиции, категории, търсене. И двете системи използват сложна архитектура с микросървиси, CDN (Content Delivery Network) за бързо зареждане на снимки, геолокация за показване на обяви близо до потребителя, и платени рекламни позиции. За дипломен проект такава сложност е излишна – достатъчно е да се реализират основните CRUD операции (Create, Read, Update, Delete), качване на една снимка на обява и проста комуникация чрез съобщения, без геолокация и микросървиси.

### 1.1.2. Facebook Marketplace

Facebook Marketplace [3] интегрира обявите директно в социалната мрежа Facebook. Предимството е в огромната потребителска база (милиарди потребители) и доверието чрез верифицираните профили – купувачът може да види профила на продавача. Потребителите могат да виждат обяви от близки до тях локации, да споделят обяви в групи и да комуникират чрез Facebook Messenger. Недостатъкът е липсата на независимост – системата е тясно свързана с Facebook екосистемата, няма собствен домейн, не може да се разширява самостоятелно и изисква Facebook акаунт. За дипломна работа е по-подходящо самостоятелно приложение с собствен backend и frontend, което демонстрира пълния стек от регистрация до разполагане, без зависимост от външни платформи за идентификация.

### 1.1.3. Специализирани e-commerce платформи

Платформи като Shopify, WooCommerce и Magento предлагат пълноценни онлайн магазини с инвентар, складова наличност, множество начини на плащане (карти, PayPal, банков превод), интеграция с куриерски компании, данъци, отчети и аналитика. Те са по-сложни и подходящи за професионални продавачи с постоянен каталог и голям обем продажби. За прости обяви между физически лица (C2C – consumer to consumer) те са прекалено тежки и скъпи – Shopify изисква месечен абонамент от няколко десетки долара, WooCommerce и Magento изискват собствен сървър, поддръжка и познания за конфигуриране. Web Shop е насочен към C2C модела – хора продават отделни вещи, не управляват магазин с инвентар.

### 1.1.4. Други платформи – Letgo, OfferUp, Carousell

Letgo (сега обединена с OfferUp) и Carousell са популярни в различни региони – САЩ, Азия, Европа. Те предлагат предимно мобилни приложения (iOS, Android), геолокация за показване на обяви в близост и опростен интерфейс за бързо качване на снимки. Общото при всички платформи е наличието на: регистрация, обяви с снимки, търсене и филтриране, комуникация между купувач и продавач, опционално плащане или доставка. За Web Shop са избрани същите основни функции, но реализирани като уеб приложение (React + Spring Boot) вместо native мобилни приложения – уеб приложението е по-лесно за разработка, работи на всички устройства чрез браузър и не изисква публикация в App Store или Google Play.

### 1.1.5. Сравнителна таблица и изводи

*Таблица 1.1. Сравнение на подобни платформи*

| Платформа | Регистрация | Обяви | Снимки | Комуникация | Плащания | Сложност |
|-----------|-------------|-------|--------|-------------|----------|----------|
| OLX | Email/социални | Да | До 20 | Чат | Бустиране | Висока |
| Bazos | Email | Да | Да | Съобщения | Бустиране | Средна |
| Facebook MP | Facebook | Да | Да | Messenger | Няма | Интегрирана |
| Web Shop (наша) | Email | Да | 1/обява | Съобщения | VIP 2€ | Средна |

От сравнението се вижда, че Web Shop покрива основните функции на платформите за обяви – регистрация, обяви, снимки, комуникация и плащане за видимост (VIP). Разликата е в опростената реализация – една снимка вместо много, прости съобщения вместо чат, фиксирана цена за VIP (2€) вместо динамично бустиране. За дипломната работа е избрана архитектура, която комбинира простотата на платформите за обяви с възможности за разширяване – в бъдеще може да се добавят множество снимки, пълноценен чат, геолокация и т.н., без да се променя фундаменталната структура.

## 1.2. Преглед на развойни средства и среди

В тази секция се прави преглед на технологиите, използвани за разработката на Web Shop – frontend, backend, база данни, hosting и платежни системи. За всяка категория се описват избраните технологии, алтернативите и обосновката за избора.

### 1.2.1. Frontend технологии

**React** [4] е най-популярната JavaScript библиотека за изграждане на потребителски интерфейси, поддържана от Meta (Facebook). Предоставя компонентно-базирана архитектура – всеки елемент от интерфейса (бутон, форма, списък) е отделен компонент, който може да се преизползва и комбинира. Виртуалното DOM оптимизира рендеринга – при промяна на данните React изчислява минималните DOM операции вместо да прерисува цялата страница. Екосистемата включва React Router за навигация, Redux или Zustand за глобално състояние, React Query за кеширане на API заявки. React 18/19 добавя подобрена конкурентност (Concurrent Mode), Suspense за асинхронно зареждане и Server Components. Избран е заради широката общност (милиони разработчици), безплатната официална документация, лесното намиране на примери и решения в Stack Overflow и GitHub, както и пазарното търсене на React разработчици.

**TypeScript** [5] добавя статична типизация към JavaScript – всяка променлива и функция има деклариран тип. Препоръчва се за по-големи проекти, тъй като открива грешки по време на компилация (правописни грешки, грешни типове, липсващи свойства), подобрява поддръжката на кода при рефакториране и предоставя по-добър IntelliSense (автодопълване) в редакторите като VS Code. Vite има вградена поддръжка за TypeScript – не е необходима допълнителна конфигурация. За Web Shop типовете (Item, User, Message и т.н.) са дефинирани в types.ts.

**Vite** [6] е съвременен build tool, създаден от Evan You (автор на Vue.js). За разлика от Webpack, който bundle-ва целия код преди стартиране, Vite използва нативни ES модули – dev сървърът стартира за милисекунди, а Hot Module Replacement (HMR) обновява промените под секунда. За production build използва Rollup за оптимизиран bundle. Официалният шаблон за React + TypeScript (npm create vite@latest) е готов за употреба. Vite е избран заради бързината и простотата – идеален за итеративна разработка.

**Алтернативи:** Vue.js е по-прост за начинаещи, но с по-малка общност. Angular е enterprise-ориентиран, по-тежък и изисква повече време за обучение. Svelte генерира малък bundle, но е по-малко популярен. React е избран заради баланса между мощност, популярност и наличност на ресурси.

### 1.2.2. Backend технологии

**Java и Spring Boot** [7] са индустриалният стандарт за enterprise приложения. Java 17 LTS (Long Term Support) предлага дългосрочна поддръжка до 2029 г. Spring Boot опростява конфигурацията чрез „convention over configuration“ – разумни стойности по подразбиране, минимална конфигурация. Предоставя вграден Tomcat сървър (не е необходимо да се инсталира отделно), автоматично свързване на компоненти чрез dependency injection и богата екосистема: Spring Security за автентикация и авторизация, Spring Data JPA за работа с база данни (ORM), Spring Web за REST контролери. За дипломен проект е достатъчно познание на основните анотации: @RestController, @Service, @Repository, @Entity, @Transactional. Spring Boot автоматично конфигурира всичко при стартиране.

**Node.js с Express** е популярна алтернатива – един език (JavaScript/TypeScript) за frontend и backend, асинхронна природа, голяма общност. Java е избран заради по-добрата статична типизация, зрелостта на Spring екосистемата (десетилетия развитие), подходящостта за production (многопоточност, стабилност) и по-добрата поддръжка от hosting платформи за Java приложения – Render, Heroku, Railway всички поддържат Java изходно.

### 1.2.3. Бази данни

**H2 Database** [8] е вградена Java база данни, написана изцяло на Java – не изисква отделен сървър. Поддържа file-based режим за персистентност – данните се записват в .mv.db файл на диска и остават след рестарт на приложението. In-memory режимът е полезен за бързи тестове. JDBC интерфейсът е стандартен – при нужда от миграция към PostgreSQL или MySQL промените са минимални. Важно за Render.com: безплатният план има ефемерна файлова система при рестарт на сървъра (след 15 мин неактивност), но file-based H2 работи в рамките на една сесия – данните се запазват докато сървърът работи. За по-голяма надеждност може да се използва Render persistent disk (платен) или външна база (напр. PostgreSQL на Render).

**Алтернативи:** PostgreSQL и MySQL са по-подходящи за големи production системи – изискват отделен database сървър, но предлагат по-добра мащабируемост и инструменти. H2 е избран заради простотата (zero configuration – Spring Boot автоматично го конфигурира), съвместимостта с Render.com (работи в същия контейнер като приложението) и подходящостта за дипломен проект с ограничен обем данни.

### 1.2.4. Платформи за разполагане

**Vercel** [9] предлага безплатен хостинг за статични сайтове – React приложението се build-ва с `npm run build` и резултатът (папка dist/) се serve-ва чрез CDN. Оптимизиран е за React и Next.js – автоматично разпознава проекта и конфигурира build командите. Деплойът е автоматичен при push към GitHub – всеки commit може да генерира preview URL. Предоставя HTTPS, CDN за бързо зареждане в цял свят и аналитика. Ограничения на безплатния план: 100GB bandwidth/месец, 6000 build минути/месец – достатъчно за дипломен проект.

**Render.com** [10] предоставя безплатен хостинг за backend сървъри (Web Services). Java/Spring Boot приложенията се build-ват с Maven (./mvnw clean package) и стартират с java -jar target/*.jar. Render автоматично разпознава pom.xml и конфигурира build и start командите. Ограничение на безплатния план: сървърът спира след 15 минути неактивност – при първа заявка след това има „cold start“ от 50–60 секунди, докато сървърът се стартира. Решение: UptimeRobot (безплатен) да прави HTTP заявка към /items/ping или /health на всеки 10 минути – така сървърът остава активен.

**GitHub** се използва за version control (Git), съвместна работа и CI/CD интеграция (GitHub Actions). Репозиторието се свързва директно с Vercel и Render – при всеки push се прави автоматичен деплой. Това улеснява итеративната разработка и демонстрацията на актуална версия.

### 1.2.5. Платежни системи

**Stripe** [11] е водеща платформа за онлайн плащания, използвана от милиони компании. Предоставя API за приемане на карти, PCI DSS compliance (данните на картата не минават през нашия сървър – Stripe обработва плащането), тестови карти за development (4242 4242 4242 4242), webhooks за уведомления. За VIP обявите в текущата версия се използва симулиран flow – backend записва плащането и активира VIP без реална транзакция. В production може да се интегрира Stripe Elements (форма за карта) или Stripe Checkout (редирект към Stripe страница) за реални плащания.

---

# ГЛАВА 2. ИЗИСКВАНИЯ, ПРОЕКТИРАНЕ И АРХИТЕКТУРА НА WEB SHOP

## 2.1. Функционални изисквания към програмния продукт

Съгласно заданието за дипломната работа, системата трябва да отговаря на следните изисквания:

**ФИ-1.** Регистрация и вход на потребители с email и парола. Паролата трябва да е минимум 8 символа и да съдържа поне един специален символ. При успешна регистрация потребителят влиза автоматично. Сесията се пази чрез localStorage (email).

**ФИ-2.** Създаване, преглед, редактиране и изтриване на обяви. Само собственикът може да редактира и изтрива своите обяви. Обявите се показват в списък с възможност за филтриране по категория. VIP обявите се показват първи в списъка.

**ФИ-3.** Качване на снимки към обявите. Снимката се включва директно в JSON body при създаване (base64 data URI). Компресия до 0.3MB на клиента. GET /items/list връща обяви без снимки за по-лек отговор; снимката се зарежда при отваряне на детайлите.

**ФИ-4.** Категоризация на обявите: Електроника, Книги, Дрехи, Спорт, Дом и градина, Автомобили, Други. Потребителят избира категория при създаване. Филтърът по категория е наличнен в списъка с обяви.

**ФИ-5.** VIP статус за обяви срещу плащане от 2€. При създаване потребителят може да избере опция VIP; след създаване на обявата се показва форма за плащане с карта. След успешно плащане обявата получава isVip=true и се показва в началото на списъка.

**ФИ-6.** Система за поръчки с начин на плащане (в брой при доставка, банков превод, карта) и доставка (куриер, лично предаване, пощенска пратка). Формата изисква име, телефон, email, адрес за доставка.

**ФИ-7.** Система за съобщения между купувачи и продавачи. Купувачът може да изпрати въпрос по обява; продавачът получава съобщението и може да отговори. Съобщенията се групират по обява.

**ФИ-8.** Ревюта и оценки за обяви. Потребителите (различни от собственика) могат да добавят ревю с рейтинг (1–5) и коментар. Ревютата се показват в детайлите за обява.

**ФИ-9.** Многоезичност (български, английски, руски). Всички текстове в интерфейса са в translations.ts; потребителят избира език от header. При смяна на езика целият интерфейс се прерисува.

## 2.2. Аргументиран избор на софтуерните средства

Изборът на технологии е направен на база проучването от Глава 1. Всяка технология е избрана с конкретна обосновка, свързана с изискванията на проекта и наличните ресурси.

*Таблица 2.1. Аргументиран избор на технологии*

| Компонент | Избор | Обосновка |
|-----------|-------|-----------|
| Frontend | React + TypeScript + Vite | React – най-популярна библиотека, богата екосистема, пазарно търсене. TypeScript – открива грешки по време на компилация, по-добра поддръжка. Vite – бързо стартиране, HMR под секунда, готов шаблон. |
| Backend | Java 17 + Spring Boot 3.2 | Java 17 LTS – дългосрочна поддръжка. Spring Boot – convention over configuration, вграден сървър, dependency injection, Spring Data JPA, Spring Security. Индустриален стандарт за enterprise. |
| База данни | H2 (file-based) | Zero configuration, работи в същия процес, file-based персистентност. Съвместим с Render.com (няма нужда от отделен DB сървър). Лесна миграция към PostgreSQL при нужда. |
| Плащания | Stripe [11] | PCI DSS compliance – данните на картата не минават през нашия сървър. Тестови карти за development. Добра документация и API. |
| Хостинг | Vercel + Render.com | Безплатен tier – достатъчен за дипломен проект. Vercel – оптимизиран за React, автоматичен деплой. Render – поддържа Java, автоматичен build. |

Алтернативите (Vue.js, Node.js, PostgreSQL, Netlify) са прегледани, но избраните технологии предлагат най-добрия баланс между простота, документация и поддръжка за образователен проект с ограничен срок.

## 2.3. Описание на алгоритъма и архитектурата

Системата следва класическата трислойна архитектура, при която всеки слой има ясно определена отговорност и комуникира с другите чрез стандартни интерфейси. Това улеснява поддръжката, тестването и възможната замяна на компоненти (напр. преминаване от H2 към PostgreSQL без промяна на бизнес логиката).

Системата следва трислойна архитектура (Фигура 2.1):

```
┌─────────────────────────────────────────┐
│   Presentation Layer (React Frontend)   │
│   └─────────── HTTP/REST ──────────────┘
│                    │
┌─────────────────────────────────────────┐
│   Application Layer (Spring Boot)       │
│   └─────────── JPA/Hibernate ───────────┘
│                    │
┌─────────────────────────────────────────┐
│   Data Layer (H2 Database)              │
└─────────────────────────────────────────┘
```

*Фигура 2.1. Трислойна архитектура на системата*

Алгоритъмът за създаване на обява с VIP плащане (Фигура 2.2):
1. Потребителят попълва формата и избира VIP;
2. Frontend изпраща POST /items;
3. Backend създава обявата и връща ID;
4. Ако VIP е избран – показва се форма за плащане;
5. Потребителят попълва данните на картата;
6. Frontend изпраща POST /vip-payment/create и /vip-payment/complete;
7. Backend обработва плащането чрез Stripe и активира VIP;
8. Frontend качва снимката чрез POST /upload/{itemId}.

*Фигура 2.2. Алгоритъм за създаване на обява с VIP*

Алгоритъмът за изпращане на съобщение (Фигура 2.3): 1) Купувачът отваря детайлите за обява; 2) Натиска „Въпрос до продавача“ или отива в „Съобщения“; 3) Избира обява и въвежда текст; 4) Frontend изпраща POST /items/{itemId}/messages с {senderEmail, content}; 5) Backend създава Message и го свързва с Item; 6) Продавачът вижда съобщението в „Получени“; 7) Въвежда отговор и изпраща PUT /items/messages/{id}/response; 8) Backend записва response в Message.

Алгоритъмът за поръчка: 1) Купувачът отваря детайлите, натиска „Поръчка“; 2) Попълва форма (име, телефон, email, плащане, доставка, адрес); 3) Frontend изпраща POST /item-orders; 4) Backend създава ItemOrder със статус „нова“; 5) Продавачът вижда поръчката в „Поръчки към мен“; 6) Може да промени статуса (потвърдена, изпратена, доставена) чрез PUT /item-orders/{id}/status.

*Фигура 2.3. Алгоритъм за съобщения и поръчки*

## 2.4. Структура на базата данни

Базата данни съдържа следните основни таблици (Таблица 2.2):

| Таблица | Описание |
|---------|----------|
| USER | Потребители (email, парола, име) |
| ITEM | Обяви (заглавие, описание, цена, категория, isVip) |
| REVIEW | Ревюта (рейтинг, коментар) |
| ITEM_ORDER | Поръчки (клиент, статус, доставка) |
| VIP_PAYMENT | VIP плащания (сума, статус) |
| MESSAGE | Съобщения (изпращач, съдържание) |
| FAVORITE | Любими обяви |

*Таблица 2.2. Основни таблици в базата данни*

*Таблица 2.3. Детайли на колоните (основни полета)*

| Таблица | Колона | Тип | Описание |
|---------|--------|-----|----------|
| USER | id | BIGINT PK | Автоинкремент |
| USER | email | VARCHAR UNIQUE | Email на потребителя |
| USER | password | VARCHAR | BCrypt хеш |
| ITEM | id | BIGINT PK | Автоинкремент |
| ITEM | title, description | VARCHAR | Заглавие, описание |
| ITEM | price | DECIMAL | Цена в лева |
| ITEM | image_base64 | CLOB | Base64 снимка |
| ITEM | is_vip | BOOLEAN | VIP статус |
| MESSAGE | content | VARCHAR | Текст на съобщението |
| MESSAGE | response | VARCHAR | Отговор на продавача |

*Фигура 2.4. Entity-Relationship схема:* User има много Item (един потребител може да има много обяви); Item има много Review, ItemOrder, Message (една обява може да има много ревюта, поръчки и съобщения); Item е свързан с VipPayment (една обява може да има едно VIP плащане) и Favorite (много потребители могат да добавят една обява към любими). Релациите са реализирани чрез foreign key колони (напр. item_id в таблицата MESSAGE).

Базата данни се създава автоматично при първо стартиране на приложението. Файлът се записва в `./data/webshopdb.mv.db` (H2 file-based режим). Конфигурацията в application.properties: DB_CLOSE_DELAY=-1 (базата не се затваря при последното свързване), DB_CLOSE_ON_EXIT=FALSE (не се затваря при изход от приложението), AUTO_SERVER=FALSE (embedded режим). H2 Console е достъпна на http://localhost:8080/h2-console за визуален преглед и SQL заявки при разработка. JPA ddl-auto=update означава, че при промяна на entity класовете Hibernate автоматично добавя нови колони или таблици, без да изтрива данни [7].

## 2.5. Сценарий на Web страницата

Сценарият на уеб приложението описва основните екрани и потребителски потоци – какво вижда потребителят на всеки екран, какви действия може да извърши и как системата реагира. Приложението е Single Page Application (SPA) – няма пълно презареждане на страницата; превключването между екрани става чрез промяна на view state в App.tsx.

**Екран 1 – Начална страница / Вход:** Неаутентикиран потребител вижда форма за вход с полета email и парола, бутон „Вход“ и линк „Регистрация“. При грешни данни (невалиден email/парола) се показва съобщение в червена кутия (alert-error). При успешен вход потребителят се пренасочва към списъка с обяви (view="all"), вижда зелено съобщение за успешен вход и email-ът се запазва в localStorage. Ако backend-ът е бавен (cold start), се показва спинър до 30 секунди.

**Екран 2 – Регистрация:** Полета за email, парола (с валидация – минимум 8 символа, поне един специален като !, @, #), пълно име. Бутон „Регистрация“ и линк „Вход“. При успех – автоматичен вход (без необходимост от повторно въвеждане), пренасочване към обявите, зелено съобщение. При „Email already in use“ – червено съобщение. Timeout 90 секунди за cold start.

**Екран 3 – Списък с обяви:** Header с линкове: Обяви (всички), Моите обяви, VIP обяви, Любими, Поръчки, Съобщения, избор на език, Изход. Филтър по категория (падащо меню). Сетка от картички – всяка показва заглавие, цена, категория, снимка (или placeholder). VIP обявите са отбелязани (напр. badge) и са сортирани първи. Клик върху карта – отваря детайли (view="detail", selectedItem=кликнатата обява).

**Екран 4 – Детайли за обява:** Пълно описание, цена в лева, контакт (email/телефон), снимка (ако има), бутони: Поръчка (отваря форма), Въпрос до продавача (пренасочва към Съобщения), Добави към любими, Ревю (форма с рейтинг 1–5 и коментар). Списък с съществуващи ревюта. Ако потребителят е собственик (ownerEmail === loggedInEmail) – бутони Редактиране, Изтриване, Качи снимка. Бутон „Назад“ връща към списъка.

**Екран 5 – Форма за създаване на обява:** Показва се при view="mine" и showCreateForm=true. Полета: заглавие, описание, цена, категория, контакт email, контакт телефон (поне едно задължително), снимка (file input), начин на плащане (в брой, превод, карта), checkbox VIP (2€). Email се попълва автоматично от loggedInEmail. При избор на VIP – след успешно създаване се отваря модал VipPaymentForm. След създаване формата се затваря и новата обява се показва в детайли.

**Екран 6 – Съобщения:** Две секции – „Изпратени“ (въпроси, които потребителят е изпратил към продавачи) и „Получени“ (въпроси към обявите на потребителя). Избор на обява от списък. Текстово поле за ново съобщение или отговор. Бутон „Изпрати“ (disabled при isSendingQuestion). Списък с съобщения по обява – показва senderEmail, content, response (ако има).

**Екран 7 – Поръчки:** Два таба – „Мои поръчки“ (поръчките на потребителя като купувач) и „Поръчки към мен“ (поръчки към обявите на потребителя като продавач). Всяка поръчка показва обява, клиент, статус, адрес. Продавачът може да промени статуса чрез падащо меню (нова → потвърдена → изпратена → доставена). Бутон за преглед на обява.

**Екран 8 – Любими:** Списък с обяви, добавени към любими. Всяка карта има бутон „Премахни от любими“. Клик върху обява – отваря детайли. При празен списък – съобщение „Нямате любими обяви“.

## 2.6. REST API дизайн

API-то следва REST (Representational State Transfer) конвенциите за дизайн на уеб услуги [12]. HTTP методите имат семантично значение: GET за четене на ресурси (идемпотентно – многократно извикване дава същия резултат), POST за създаване на нови ресурси, PUT за обновяване на съществуващи, DELETE за изтриване. Ресурсите са именувани в множествено число (/items, /favorites, /item-orders) и представляват съществителни, не глаголи. Вложените ресурси използват path параметри: /items/{id}/messages означава „съобщенията за обява с дадено id“. Отговорите са в JSON формат (Content-Type: application/json) за лесно парсване от JavaScript. При грешка се връща подходящ HTTP статус код: 400 Bad Request (невалидни данни), 401 Unauthorized (неоторизиран достъп), 404 Not Found (ресурсът не съществува), 500 Internal Server Error (сървърна грешка), и съобщение в тялото (обикновено текст или JSON с полето error). CORS (Cross-Origin Resource Sharing) headers са конфигурирани в CorsConfig – frontend-ът (напр. на Vercel) е на различен домейн от backend-а (на Render), затова браузърът изисква CORS headers за да разреши заявките. Текущата конфигурация разрешава всички origins (*) за development; за production може да се ограничи до конкретни домейни.

---

# ГЛАВА 3. РЕАЛИЗАЦИЯ НА WEB SHOP ПЛАТФОРМАТА

В тази глава се описва начинът на реализация на алгоритмите и сценария от Глава 2 – как са разработени backend и frontend компонентите, как комуникират помежду си, как се обработват грешките и как се конфигурира приложението. Главата съдържа фрагменти от сорс кода с обяснения, описание на компонентната структура и решенията, взети при реализацията.

## 3.1. Обща структура на проекта

Проектът е организиран в две основни части – backend (Java/Spring Boot) и frontend (React/TypeScript). Те работят като отделни приложения: backend-ът е REST API сървър на порт 8080, frontend-ът е Single Page Application (SPA), който се зарежда от статичен сървър (Vite dev на порт 5173 или Vercel в production) и прави HTTP заявки към backend-а. Разделянето позволява независимо разработване, тестване и разполагане на двата компонента. Структурата е показана на Фигура 3.1.

```
Diplomnarabota/
├── backend/web-shop/                    # Spring Boot приложение
│   ├── src/main/java/com/example/webshop/
│   │   ├── controllers/                 # REST контролери (Auth, Item, Message, FileUpload, VipPayment, Favorite, ItemOrder, Health)
│   │   ├── services/                    # Бизнес логика (UserService, ItemService, MessageService, ...)
│   │   ├── repositories/                # JPA репозитории (UserRepository, ItemRepository, ...)
│   │   ├── models/                      # Entity класове (User, Item, Message, Review, Favorite, ItemOrder, VipPayment)
│   │   ├── dto/                         # Data Transfer Objects (AddMessageRequest, CreateItemOrderRequest)
│   │   └── config/                     # Конфигурация (SecurityConfig, CorsConfig, MultipartConfig)
│   ├── src/main/resources/
│   │   └── application.properties       # Настройки (порт, H2, multipart, encoding, actuator)
│   ├── pom.xml                          # Maven зависимости
│   └── mvnw, mvnw.cmd                   # Maven Wrapper
└── web-shop-frontend/                   # React приложение
    ├── src/
    │   ├── components/                  # React компоненти (Header, LoginPage, ItemList, ItemDetail, ...)
    │   ├── App.tsx                      # Главен компонент, state, handlers
    │   ├── App.css                      # Стилове
    │   ├── main.tsx                     # Entry point
    │   ├── config.ts                    # API_BASE URL
    │   ├── types.ts                     # TypeScript типове
    │   └── translations.ts              # Многоезични текстове (bg, en, ru)
    ├── package.json                     # npm зависимости
    └── vite.config.ts                   # Vite конфигурация
```

*Фигура 3.1. Структура на проекта*

Backend пакетът com.example.webshop съдържа всички Java класове. Frontend src/ съдържа всички изходни файлове; при build (npm run build) се генерира dist/ с оптимизирани HTML, CSS, JS.

## 3.2. Backend реализация

### 3.2.1. REST контролери

Контролерите са класове, аннотирани с @RestController, които обработват HTTP заявки и връщат отговори. Всеки контролер е отговорен за един ресурс или група свързани операции. Spring автоматично мапва URL пътищата към методите чрез анотациите @GetMapping, @PostMapping, @PutMapping, @DeleteMapping.

**AuthController** (`/auth`) обработва автентикация – регистрация и вход. Приема User обект в тялото на заявката (JSON), валидира дали email, password и fullName не са null или празни, и делегира на UserService. При успешна регистрация връща "REGISTER_OK", при успешен вход – "LOGIN_OK". При грешка връща HTTP 400 или 401 с текст на грешката. Съдържа логване (logger.info, logger.error) за проследяване на операциите. Endpoint `/auth/health` служи за „подгряване“ на Render.com при cold start – лека GET заявка, която връща "OK":

```java
@GetMapping("/health")
public ResponseEntity<String> health() {
    return ResponseEntity.ok("OK");
}
```

*Фигура 3.2. Фрагмент от AuthController – health endpoint*

**HealthController** (`/health`) – root health endpoint на корена на приложението. Използва се от UptimeRobot за мониторинг (ако endpoint-ът не отговори, UptimeRobot изпраща alert) и за бърза проверка дали backend-ът работи. Връща "OK" с HTTP 200.

**ItemController** (`/items`) – CRUD: POST (Item с imageUrl base64 в body), GET /items/list (списък без imageUrl), GET /{id} (пълен item), PUT, DELETE. Важна техническа корекция: първоначално мапването `@GetMapping("/{id}")` прихващаше всички path сегменти, включително "ping" – при заявка към `/items/ping` Spring опитваше да парсне "ping" като Long id и връщаше 400 Bad Request. Решението е `@GetMapping("/{id:[0-9]+}")` – path variable е ограничен до цифри (регулярен израз [0-9]+), така че `/items/ping` се мапва към отделния метод `@GetMapping("/ping")`. Endpoint `/items/ping` е лека заявка (връща "OK") за поддържане на сървъра активен чрез UptimeRobot.

**FileUploadController** (`/upload/{itemId}`) – опционален endpoint за добавяне на снимка към съществуваща обява (multipart/form-data). Основният flow е снимка в JSON body при POST /items (imageUrl като base64). TomcatConfig maxPostSize 20MB за create. При upload снимките се записват в imageUrl на Item (base64, за Render.com ефемерна ФС).

**MessageController** използва DTO `AddMessageRequest` (senderEmail, content) вместо директно Message entity – по-безопасно и ясно. Endpoints: POST /items/{itemId}/messages, GET /items/messages/sent/{email}, GET /items/messages/received/{email}, PUT /items/messages/{id}/response.

**VipPaymentController** – POST /vip-payment/create (създава плащане, връща paymentId), POST /vip-payment/complete (завършва плащането и активира VIP). **FavoriteController** – GET /favorites/{email}, POST /favorites, DELETE /favorites/{email}/{itemId}. **ItemOrderController** – POST /item-orders, GET /item-orders/customer/{email}, GET /item-orders/seller/{email}, PUT /item-orders/{id}/status.

### 3.2.2. Service слой

UserService използва BCrypt за хеширане на паролите:

```java
String encodedPassword = passwordEncoder.encode(password);
User newUser = new User(email, encodedPassword, fullName);
return userRepository.save(newUser);
```

*Фигура 3.3. Фрагмент от UserService.register()*

ItemService, VipPaymentService, MessageService и OrderService съдържат бизнес логиката. Всички промени в базата са обвити в @Transactional. Spring Boot Actuator е включен (management.endpoints.web.exposure.include=health) за /actuator/health.

**ItemService** – create(), getAllForList() (без imageUrl), getById(), update(), delete(). При create() се проверява ownerEmail; imageUrl приема base64 от body. **VipPaymentService** – създава запис за плащане, при complete() активира VIP на обявата. **MessageService** – addMessage() приема itemId и Message, addResponse() добавя отговор към съществуващо съобщение. **ItemOrderService** – createOrder() създава поръчка, getByCustomer() и getBySeller() връщат списъци.

### 3.2.3. Модели и релации

**User** – id, email (unique), password (BCrypt), fullName. **Item** – id, title, description, price, ownerEmail, category, contactEmail, contactPhone, paymentMethod, imageUrl (base64), isVip. OneToMany към Review, Message, ItemOrder. @JsonView(WithImage) на imageUrl – включва се само при GET /items/{id}; при Message/Favorite се изключва за по-лек JSON.

**Review** – id, itemId, authorEmail, rating, comment. **Message** – id, itemId, senderEmail, content, response (nullable). Message използва FetchType.EAGER за item. **Favorite** използва `@ManyToOne(fetch = FetchType.EAGER)` за Item – това решава грешката „Failed to fetch“ при отваряне на страницата за любими, тъй като Item се зарежда веднага при достъп до Favorite. **ItemOrder** – customerEmail, customerName, customerPhone, itemId, paymentMethod, deliveryMethod (speedy_address, speedy_office, econt_address, econt_office), deliveryAddress, status. **VipPayment** – itemId, amount, status, paymentId.

### 3.2.4. Repository слой

Spring Data JPA предоставя автоматична имплементация на репозиториите чрез разширяване на JpaRepository. UserRepository, ItemRepository, ReviewRepository, MessageRepository, FavoriteRepository, VipPaymentRepository, ItemOrderRepository – всеки наследява JpaRepository<Entity, Long> и получава методите findAll(), findById(), save(), deleteById() без допълнителен код. При нужда се добавят custom методи с @Query (напр. findByOwnerEmail за Item). Транзакциите се управляват от @Transactional в service слоя.

## 3.3. Frontend реализация

### 3.3.1. Компонентна структура

App.tsx е главният компонент, който управлява състоянието и рутирането чрез view state. Основните компоненти са (Фигура 3.4):

- **Header** – навигационна лента с линкове (Обяви, Моите обяви, VIP обяви, Любими, Поръчки, Съобщения), избор на език (bg/en/ru) и бутон за изход. Показва се на всички страници. При смяна на езика се обновява language state и всички компоненти се прерисуват с новите текстове.

- **LoginPage, RegisterPage** – форми за вход и регистрация. Получават isLoggingIn/isRegistering като props – при true показват спинър и блокират полетата, за да се предотврати двойно изпращане. При грешка показват съобщение в червена кутия.

- **CreateListingForm** – форма с полета за заглавие, описание, цена, категория, контакт (email, телефон), снимка, начин на плащане, VIP checkbox. Получава loggedInEmail – при отваряне email полето се попълва автоматично. isCreating блокира бутона при изпращане. Валидация на клиента преди изпращане.

- **ItemList, ItemCard, ItemDetail** – ItemList рендерира списък от ItemCard компоненти; ItemCard показва карта с обява (заглавие, цена, категория, снимка); ItemDetail показва пълните детайли с бутони за поръчка, въпрос, любими, ревю.

- **VipPaymentForm** – модално прозорец с полета за карта (номер, име, срок, CVV). Показва се след създаване на обява с избрана VIP опция. При успешно плащане затваря се и обявата се обновява.

- **MessagesPage** – две секции (изпратени/получени), избор на обява, текстово поле за съобщение или отговор. isSendingQuestion блокира бутона при изпращане.

- **FavoritesPage, OrdersPage, VipListingsPage** – списъци с любими обяви, поръчки (като купувач и продавач), само VIP обяви.

API_BASE се конфигурира в config.ts от VITE_API_BASE_URL или fallback към production URL.

**Управление на състоянието в App.tsx:** Главният компонент държи всички state променливи – loggedInEmail (от localStorage), view (текущ екран), items, selectedItem, selectedCategory, showCreateForm, полетата на формите (newItemTitle, newItemDescription и т.н.), reviews, messages, orders, favorites, language, error, message. Няма външен state manager (Redux, Zustand) – за обхвата на проекта локалният state е достатъчен. Callback функциите (handleLogin, handleCreateListing, loadItems и т.н.) се подават като props към децата. При промяна на view се изпълняват useEffect за зареждане на данни (напр. loadFavorites при view===„favorites“).

*Фигура 3.4. Компонентна структура на frontend*

### 3.3.2. API комуникация

Всички заявки се извършват чрез fetch API:

```typescript
const res = await fetch(`${API_BASE}/items`, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ title, description, price, ... })
});
```

*Фигура 3.5. Пример за API заявка*

За бавни операции се използва AbortController с timeout – при login 30 секунди (ако сървърът е активен, отговорът е под 5 сек), при register 90 секунди (заради Render.com cold start ~50–60 сек при първа заявка). При timeout controller.abort() прекъсва заявката и се хваща AbortError – потребителят вижда съобщение „Заявката отне твърде много време“. При регистрация и вход се показва спинър (`isLoggingIn`, `isRegistering`) и полетата се блокират с disabled, за да се предотврати двойно натискане. При изпращане на съобщение – `isSendingQuestion` и disabled бутони. **Подгряване на backend:** при зареждане на приложението (useEffect с празен dependency array) и при отваряне на login/register страницата се изпраща заявка към `/items/ping`, при неуспех – към `/actuator/health`, при неуспех – към `/items`. Целта е да се „подгрее“ сървърът преди потребителят да натисне „Вход“ или „Регистрация“ – така cold start се случва по време на зареждане на страницата, а не по време на действието.

### 3.3.3. Многоезичност

Файлът translations.ts съдържа обект с ключове bg, en, ru; всяка стойност е обект с ключове за всеки текст (напр. login, register, successRegistration, errorLogin, navAll, navMine, navVip, navFavorites, navOrders, navMessages, navMore). Компонентите получават language като prop и извличат t = translations[language]. При промяна на language (от Header) всички компоненти се прерисуват с новите текстове. Няма i18n библиотека – за три езика достатъчно е прост обект.

**Стилизация (App.css):** Използват се CSS променливи (:root) за цветове, градиенти, сенки. Класовете .alert, .alert-success, .alert-error, .alert-warning имат solid цветове с !important за надеждно показване. Картичките с обяви използват градиентни фонове и hover ефекти. Дизайнът е responsive – медиа заявки за по-малки екрани.

### 3.3.4. Обработка на снимки

Снимката се включва директно в JSON body при POST /items (поле imageUrl като base64 data URI). Компресия до 0.3MB (fileToBase64DataUri + compressImage). GET /items/list връща обяви без imageUrl – избягва се огромен отговор и 500 на Render. При отваряне на детайли (GET /items/{id}) се зарежда пълният item със снимка. JsonView изключва imageUrl при сериализация в Message – страницата „Съобщения“ не претоварва отговора.

### 3.3.5. Съобщения и навигация

Съобщенията за успех/грешка (alert-success, alert-error, alert-warning) остават видими при смяна на страница – изчистват се само при промяна на view чрез useEffect. Формата за създаване на обява се затваря автоматично при превключване от „Моите обяви“ към „Обяви“. Email полето в формата се попълва автоматично с loggedInEmail при отваряне.

## 3.4. Сигурност

**SecurityConfig:** CSRF е изключен (REST API не използва cookies за сесия), session е STATELESS. Всички endpoints са permitAll() – за дипломен проект няма JWT; автентикацията е чрез проверка на ownerEmail при чувствителни операции. Публични endpoints: `/auth/**`, `/items/**`, `/item-orders/**`, `/upload/**`, `/vip/**`, `/vip-payment/**`, `/health`, `/auth/health`, `/actuator/**`. Паролите се хешират с BCrypt (strength 6). JPA/Hibernate използва prepared statements – предотвратява SQL injection. React escape-ва HTML по подразбиране (XSS защита) [12]. CORS е конфигуриран в CorsConfig – разрешени всички origins за development; за production може да се ограничи. За VIP плащания – само последните 4 цифри на картата се изпращат [11]; пълните данни не се съхраняват.

## 3.5. Обработка на грешки и edge cases

**Backend:** Валидация на входните данни във всеки controller – проверка за null обекти, празни полета (trim().isEmpty()), невалидни стойности (напр. price <= 0). При грешка се връща ResponseEntity с подходящ HTTP статус: 400 Bad Request за невалидни данни (с текст на грешката в body), 401 Unauthorized за грешен email/парола при login, 404 Not Found ако ресурсът не съществува, 500 Internal Server Error за неочаквани изключения (с generic съобщение, детайлите се логват). Всички controllers са обвити в try-catch; при RuntimeException (бизнес грешки като „Email already in use“) се връща 400, при Exception – 500. Логване с SLF4J/Logback (logger.info за успешни операции, logger.error за грешки) позволява проследяване при дебъг.

**Frontend:** При всяка fetch заявка се проверява res.ok; при !res.ok се чете responseText (или response.json() ако е JSON) и се показва в alert-error (червена кутия). Специфична обработка: AbortError (timeout) – съобщение „Заявката отне твърде много време“; Failed to fetch или NetworkError – „Не може да се свърже със сървъра“; „Email already in use“ – „Този email вече се използва“. Съобщенията са на съответния език (language state). При любими – при network error или timeout не се показва грешка на потребителя (setError не се извиква), за да не се обърква при cold start – вместо това се показва празен списък и при следващо отваряне данните ще се заредят ако сървърът е активен.

## 3.6. Конфигурация и environment

**Backend application.properties:** server.port не е зададен – по подразбиране 8080. H2 URL: jdbc:h2:file:./data/webshopdb с параметри DB_CLOSE_DELAY=-1, DB_CLOSE_ON_EXIT=FALSE. Multipart: max-file-size=20MB, max-request-size=20MB, file-size-threshold=0 (файловете се държат в паметта – важно за Render без персистентен диск). Encoding: UTF-8 за request/response (поддръжка на кирилица). Actuator: management.endpoints.web.exposure.include=health. Logging: DEBUG за com.example.webshop. STRIPE_SECRET_KEY се задава като environment variable в Render (не в кода – за сигурност).

**Frontend config.ts:** API_BASE = import.meta.env.VITE_API_BASE_URL || "https://webshop-e6dx.onrender.com". Vite inject-ва environment variables с префикс VITE_ по време на build. При npm run build се генерира статичен build в dist/ (HTML, CSS, JS); Vercel serve-ва тези файлове чрез CDN. За локална разработка VITE_API_BASE_URL=http://localhost:8080 в .env.

## 3.7. Екрани от приложението

*[Тук се поставят екрани с номерация Фигура 3.6, 3.7, 3.8, 3.9, 3.10 – начална страница (Фигура 3.6), форма за регистрация (Фигура 3.7), списък с обяви (Фигура 3.8), детайли за обява (Фигура 3.9), форма за VIP плащане (Фигура 3.10), страница за съобщения (Фигура 3.11). При печат – снимки на екраните с подписи, по една фигура на страница или две при по-малък размер.]*

---

# ГЛАВА 4. РЪКОВОДСТВО ЗА ПОТРЕБИТЕЛЯ НА WEB SHOP

## 4.1. Изисквания към компютърната конфигурация

**За използване на онлайн версията (Vercel + Render):**
- Модерен уеб браузър (Chrome 90+, Firefox 88+, Edge 90+, Safari 14+);
- Интернет връзка със стабилна скорост;
- JavaScript включен (по подразбиране е включен във всички съвременни браузъри);
- Разрешен cookies и localStorage (за запазване на сесията);
- Разрешен трети-party контент ако има блокери на реклами (някои могат да блокират API заявките).

**За локално стартиране:**
- Java JDK 17 или по-нова версия (проверка: java -version);
- Node.js 18 или по-нова версия (проверка: node -version);
- npm (идва с Node.js) или yarn;
- Maven 3.8+ или Maven Wrapper (mvnw/mvnw.cmd в проекта);
- Минимум 512MB свободна RAM, 1GB дисково пространство;
- Свободни портове 8080 (backend) и 5173 (frontend).

## 4.2. Инсталация

### 4.2.1. Backend

Отворете терминал (Command Prompt, PowerShell или bash) и навигирайте до папката на backend-а. Използвайте Maven Wrapper (mvnw или mvnw.cmd), който е включен в проекта – не е необходимо да имате Maven инсталиран глобално.

**Windows:**
```bash
cd backend/web-shop
.\mvnw.cmd spring-boot:run
```

**Linux/Mac:**
```bash
cd backend/web-shop
./mvnw spring-boot:run
```

При първо стартиране Maven ще изтегли зависимостите (може да отнеме 1–2 минути). Backend стартира на http://localhost:8080. В конзолата ще видите „Started WebShopApplication“. Базата данни се създава автоматично в ./data/webshopdb.mv.db – при следващи стартирания данните се запазват. За да нулирате базата, изтрийте файловете webshopdb.mv.db и webshopdb.trace.db.

### 4.2.2. Frontend

Отворете нов терминал (backend трябва да продължи да работи) и навигирайте до frontend папката:

```bash
cd web-shop-frontend
npm install
npm run dev
```

npm install изтегля зависимостите (package.json). npm run dev стартира Vite development сървъра. Frontend стартира на http://localhost:5173. Отворете този URL в браузър. За да сочи към локалния backend, създайте файл .env в web-shop-frontend с съдържание: VITE_API_BASE_URL=http://localhost:8080. Ако не създадете .env, config.ts използва production URL по подразбиране.

### 4.2.3. Production разполагане

За production backend се разполага на Render.com, frontend – на Vercel. В Render: New → Web Service, свържете GitHub репозиторието, Root Directory: backend/web-shop, Build Command: ./mvnw clean package -DskipTests, Start Command: java -jar target/*.jar. В Vercel: Import репозиторието, Root Directory: web-shop-frontend, Framework: Vite. Добавете Environment Variable: VITE_API_BASE_URL=https://your-backend.onrender.com (заменете с реалния URL на Render).

**Render.com cold start:** При безплатен план сървърът спира след 15 мин неактивност. Първата заявка след това може да отнеме 50–60 секунди (cold start). Решение: регистрирайте се в UptimeRobot (безплатно), създайте HTTP(s) Monitor с URL https://your-backend.onrender.com/items/ping, интервал 5 или 10 минути. UptimeRobot ще прави заявка на всеки 5–10 мин и сървърът ще остане активен. Health endpoints за мониторинг: `/health`, `/auth/health`, `/actuator/health`, `/items/ping`.

## 4.3. Регистрация и вход

**Регистрация:**
1. Отворете началната страница и натиснете „Регистрация“ (или линк под формата за вход);
2. Попълнете email (валиден формат, напр. user@example.com);
3. Попълнете парола – минимум 8 символа, поне един специален (например !, @, #, $);
4. Попълнете пълно име (както искате да се показва);
5. Натиснете „Регистрация“. При успех ще видите зелено съобщение и ще влезете автоматично в системата. При грешка (напр. email вече съществува) ще се покаже червено съобщение.

**Вход:** Въведете email и парола в съответните полета, натиснете „Вход“. При бавна заявка (напр. cold start на Render) може да се покаже спинър – изчакайте до 90 секунди. При грешни данни ще се покаже „Invalid email or password“.

## 4.4. Създаване на обява

1. Влезте в системата и от навигацията изберете „Моите обяви“;
2. Натиснете бутона „+ Създай обява“;
3. Попълнете заглавие (кратко описание на продукта);
4. Попълнете описание (подробна информация);
5. Въведете цена в лева (положително число);
6. Изберете категория от падащото меню;
7. Въведете контакт – email и/или телефон (поне едно от двете е задължително);
8. Изберете снимка (до 10MB; ако е над 500KB, ще се компресира автоматично до ~800KB);
9. Опционално: отметнете „Направи обявата VIP (2€)“ за по-добра видимост;
10. Натиснете „Създай обява“;
11. Ако сте избрали VIP – ще се отвори модал; попълнете данните на картата (тестови: 4242 4242 4242 4242) и натиснете „Плати“. След успешно плащане обявата ще стане VIP.

## 4.5. Преглед и търсене на обяви

**Всички обяви:** От навигацията изберете „Обяви“. Ще се покаже списък с всички обяви; VIP обявите са отбелязани и са в началото. Използвайте филтъра по категория (падащо меню) за да ограничите резултатите.

**VIP обяви:** Изберете „VIP обяви“ за да видите само обяви с VIP статус.

**Детайли:** Кликнете върху карта с обява за да отворите пълните детайли – описание, цена, контакт, снимка, бутони за поръчка, въпрос, любими, ревю.

**Любими:** В детайлите натиснете „Добави към любими“ за да запазите обявата. Преглед на любимите – от навигацията „Любими“. Бутонът се променя на „Премахни от любими“ ако обявата вече е в любими.

**Редактиране и изтриване:** Само собственикът на обява вижда бутоните „Редактиране“ и „Изтриване“ в детайлите. При редактиране се отваря форма с попълнени полета; след запазване обявата се обновява. При изтриване се показва потвърждение (ако е имплементирано) и обявата се премахва от списъка.

**Ревюта:** В детайлите за обява (ако не сте собственик) можете да добавите ревю – изберете рейтинг 1–5 звезди, напишете коментар и натиснете „Добави ревю“. Ревютата се показват под формата.

## 4.6. Поръчки и съобщения

**Поръчка:**
1. Отворете детайлите за обява;
2. Натиснете „Поръчка“ или „Направи поръчка“;
3. Попълнете име, телефон, email (задължителни);
4. Изберете начин на плащане (в брой при доставка, банков превод, карта);
5. Изберете куриерска услуга (Спиди или Еконт);
6. Изберете тип доставка – до адрес или до офис на куриера;
7. Въведете адрес или офис (напр. „Офис София – Център“);
8. Натиснете „Потвърди поръчката“. Продавачът ще получи поръчката и ще може да промени статуса.

**Съобщения (въпроси до продавача):**
1. От навигацията изберете „Съобщения“;
2. Изберете обява от списъка (или от детайлите натиснете „Въпрос до продавача“);
3. Напишете съобщението в текстовото поле;
4. Натиснете „Изпрати“. Продавачът вижда съобщението в секцията „Получени“ и може да отговори. Вие виждате отговора в „Изпратени“.

## 4.7. Архивиране и съхранение

Данните се съхраняват в H2 базата. За backup копирайте файла backend/web-shop/data/webshopdb.mv.db. На Render.com данните се съхраняват в persistent disk (ако е конфигуриран).

## 4.8. Извеждане на справки

Потребителят може да преглежда: **Моите поръчки** – поръчките като купувач (от навигацията „Поръчки“, таб „Мои поръчки“); **Поръчки към моите обяви** – поръчките като продавач (таб „Поръчки към мен“); **Съобщения** – изпратени и получени съобщения по обяви; **Любими** – списък с любими обяви. Всички справки се зареждат при отваряне на съответната страница и се обновяват след действия (напр. след изпращане на съобщение).

## 4.9. Отстраняване на проблеми

**Бял екран:** F12 → Console за грешки. Проверете дали backend работи: отворете https://your-backend.onrender.com/health. Проверете CORS.

**„Failed to fetch“ / „Не може да се свърже“:** Backend не отговаря. При Render – изчакайте 50–60 сек (cold start) или настройте UptimeRobot ping на /items/ping на всеки 10 мин. При локално – backend на порт 8080.

**Регистрация/вход/създаване на обява – много бавни или AbortError:** Render cold start. Изчакайте до 90 сек. Решение: UptimeRobot или отворете страницата, изчакайте 1 мин, после натиснете бутона.

**Снимка не се качва при създаване:** Снимката е в JSON body (base64). Проверете: 1) Backend обновен – https://your-backend.onrender.com/health/build трябва да връща `{"build":"image-in-create-v2"}`; 2) Manual Deploy на Render; 3) Hard refresh (Ctrl+Shift+R). Използвайте снимка под 300KB. Ако виждате „Web Shop v2“ в заглавието – frontend е обновен.

**Страница „Съобщения“ празна или грешка:** Backend cold start или timeout. Изчакайте 1 мин и опитайте отново. F12 → Console за детайли. Timeout е 90 сек. Ако backend е обновен (JsonView за Item.imageUrl в Message), отговорът е по-лек и не трябва да дава 500.

**„Моите обяви“ или „Обяви“ – HTTP 400:** Frontend използва GET /items/list; при 400 fallback към /items. Ако и двете дават грешка – backend не е обновен. Manual Deploy на Render.

**Любими – празен списък:** При network error – опитайте отново. Уверете се, че сте логнати.

---

# ЗАКЛЮЧЕНИЕ

В настоящата дипломна работа е разработена пълнофункционална уеб платформа Web Shop за обяви и продажби. Постигнати са всички цели, поставени в увода: реализирана е система с регистрация и вход (с валидация на парола и обработка на грешки), създаване и управление на обяви (CRUD операции), качване на снимки с автоматична компресия за по-бързо качване, VIP плащания (интеграция със Stripe за production), поръчки с избор на начин на плащане и доставка, система за съобщения между купувачи и продавачи (въпроси и отговори по обяви), ревюта и оценки (рейтинг 1–5 и коментар), многоезичност на български, английски и руски, и разполагане в облака (Vercel за frontend, Render.com за backend).

Основните постижения включват: трислойна архитектура с ясно разделение между presentation (React), application (Spring Boot) и data (H2) слоеве; интеграция със Stripe за плащания с PCI DSS compliance; responsive дизайн с модерен UI (градиенти, картички, цветни съобщения за успех и грешка); поддръжка на три езика чрез прост translations обект; обработка на edge cases – cold start при Render (подгряване, timeout 90 сек за register), timeout при бавни мрежи, network errors с адекватни съобщения; health endpoints (/health, /auth/health, /actuator/health, /items/ping) за мониторинг и UptimeRobot; и пълно разполагане в облака с автоматичен деплой от GitHub. Системата е подходяща както за образователни цели (демонстрация на модерен уеб стек), така и за малки C2C платформи за обяви между физически лица.

За бъдещо развитие се предвиждат следните подобрения: JWT (JSON Web Token) автентикация вместо localStorage за по-добра сигурност и възможност за защитени endpoints; по-добро търсене и филтриране – full-text search по заглавие и описание, филтри по цена; мобилно приложение с React Native за по-добър mobile experience; административен панел за модерация на обяви и потребители; преминаване към PostgreSQL за production при по-голям обем данни; и възможност за множество снимки на обява (като OLX). Направената разработка предоставя солидна основа за тези разширения.

---

# ИЗПОЛЗВАНА ЛИТЕРАТУРА

[1] Статистика за онлайн търговията в България – НСИ, 2024.

[2] OLX – https://www.olx.bg – платформа за обяви и търговия.

[3] Facebook Marketplace – https://www.facebook.com/marketplace – обяви в социалната мрежа.

[4] React Documentation – https://react.dev – официална документация на React.

[5] TypeScript Documentation – https://www.typescriptlang.org/docs – официална документация.

[6] Vite – https://vitejs.dev – бърз build tool за frontend проекти.

[7] Spring Boot Reference – https://docs.spring.io/spring-boot – официална документация.

[8] H2 Database – https://www.h2database.com – документация на H2.

[9] Vercel – https://vercel.com – платформа за хостинг на frontend.

[10] Render – https://render.com – платформа за хостинг на backend.

[11] Stripe API – https://stripe.com/docs/api – документация за плащания.

[12] MDN Web Docs – https://developer.mozilla.org – уеб технологии.

---

# СЪДЪРЖАНИЕ

Титулна страница  
Задание за дипломна работа  
Отзив на научния ръководител  

Увод ......................................................................... 1  
Цели и задачи на дипломната работа ............................ 1  

Глава 1. Проучване на подобни системи и развойни средства .... 2  
1.1. Преглед на съществуващи подобни програмни системи .... 2  
1.2. Преглед на развойни средства и среди .................... 3  

Глава 2. Изисквания, проектиране и архитектура ................. 4  
2.1. Функционални изисквания .................................. 4  
2.2. Аргументиран избор на софтуерните средства ............ 4  
2.3. Описание на алгоритъма и архитектурата .................. 5  
2.4. Структура на базата данни ................................ 5  
2.5. Сценарий на Web страницата ............................... 6  
2.6. REST API дизайн ........................................... 6  

Глава 3. Реализация на Web Shop платформата .................... 6  
3.1. Обща структура на проекта ............................... 6  
3.2. Backend реализация ....................................... 6  
3.2.1.–3.2.4. Контролери, сървиси, модели, репозитории ....... 7  
3.3. Frontend реализация ...................................... 7  
3.4. Сигурност ................................................. 8  
3.5. Обработка на грешки и edge cases ......................... 8  
3.6. Конфигурация и environment ................................ 9  
3.7. Екрани от приложението ................................... 9  

Глава 4. Ръководство за потребителя на Web Shop ............... 9  
4.1. Изисквания към компютърната конфигурация ............... 9  
4.2. Инсталация ................................................ 10  
4.3. Регистрация и вход ........................................ 10  
4.4. Създаване на обява ........................................ 11  
4.5. Преглед и търсене на обяви ............................... 11  
4.6. Поръчки и съобщения ...................................... 11  
4.7. Архивиране и съхранение .................................. 12  
4.8. Извеждане на справки ..................................... 12  
4.9. Отстраняване на проблеми ................................. 12  

Заключение ............................................................. 12  

Използвана литература ................................................ 11  

Съдържание ............................................................. 12  

Приложение ............................................................. 13  
Приложение А. API endpoints ........................................... 13  
Приложение Б. Основни подобрения ...................................... 14  
Приложение В. TypeScript типове ...................................... 14  

---

# ПРИЛОЖЕНИЕ

**ЗАДЪЛЖИТЕЛНО (съгласно изискванията):** Всички работни файлове (фигури, алгоритми, графики, таблици, чертежи), както и текста на дипломната работа трябва да се приложат в отделна папка. Сорс кодът и работоспособният изпълним файл на програмната система трябва да се приложат в отделна папка на CD ROM или флашка, надписани с имената и випуска на дипломанта и поставени в джоб на задната корица на подвързаната ДР.

Структура на приложението:
- backend/web-shop/ – изходен код на Spring Boot backend
- web-shop-frontend/ – изходен код на React frontend
- ДОКУМЕНТАЦИЯ.md – този документ
- README.md – инструкции за инсталация

## Приложение А. API endpoints

| Метод | Endpoint | Описание |
|-------|----------|----------|
| GET | /health, /auth/health, /actuator/health | Health check |
| GET | /items/ping | Ping за UptimeRobot |
| POST | /auth/register, /auth/login | Регистрация, вход |
| GET | /items/list | Списък обяви (без imageUrl) |
| GET/POST/PUT/DELETE | /items, /items/{id} | CRUD обяви (imageUrl в create body) |
| POST | /upload/{itemId} | Добавяне на снимка към съществуваща обява (опционално) |
| GET/POST/DELETE | /favorites, /favorites/{email}/{itemId} | Любими |
| POST | /items/{itemId}/messages | Изпращане на съобщение |
| GET | /items/messages/sent/{email}, /items/messages/received/{email} | Съобщения |
| PUT | /items/messages/{id}/response | Отговор на съобщение |
| POST | /vip-payment/create, /vip-payment/complete | VIP плащане |
| POST | /vip/activate | Активиране на VIP |
| POST | /item-orders | Създаване на поръчка |

## Приложение Б. Основни подобрения по време на разработката

- **Login/Register:** Спинъри при зареждане (isLoggingIn, isRegistering), timeout 30/90 сек с AbortController, обработка на network errors (Failed to fetch) и AbortError с потребителски съобщения на съответния език. Подгряване на backend при отваряне на login/register страницата.

- **Съобщения:** Съобщенията за успех/грешка остават видими при смяна на страница (не се изчистват веднага); цветни кутии – success (зелено), error (червено), warning (жълто) с класове .alert-success, .alert-error, .alert-warning в App.css.

- **Любими:** FetchType.EAGER за Item в Favorite entity – решава „Failed to fetch“ при отваряне на страницата за любими (lazy loading причиняваше грешка при сериализация). По-добра обработка на network errors – при timeout или Failed to fetch не се показва грешка на потребителя (празен списък вместо error message).

- **Форма за обява:** Auto-fill на email от loggedInEmail при отваряне (useEffect при showCreateForm && loggedInEmail). Затваряне при смяна на view от „Моите обяви“ към „Обяви“ (useEffect при view !== "mine"). Корекция на VIP checkbox – правилни CSS класове за визуализация.

- **Health:** Добавени /health, /auth/health, /actuator/health, /items/ping – за Render мониторинг и UptimeRobot. SecurityConfig permitAll за тези endpoints.

- **/items/ping 400:** Корекция с @GetMapping("/{id:[0-9]+}") за getById – „ping“ не се мапва като id. Преди това /items/ping връщаше 400 Bad Request.

- **Снимки:** Компресия до 800KB, threshold 500KB (снимки над 500KB се компресират), max dimension 1280px – по-бързо качване и по-малко натоварване на Render.com.

- **Качване на снимки при създаване:** Снимката се включва директно в JSON body на POST /items като base64 data URI (imageUrl), вместо отделен upload endpoint. Backend: TomcatConfig maxPostSize 20MB; frontend: компресия до 0.3MB. GET /items/list връща обяви без imageUrl (избягва 500). **Деплой:** Manual Deploy на Render за backend; hard refresh (Ctrl+Shift+R).

- **Съобщения (чат):** Item.imageUrl се изключва при сериализация в Message (JsonView) – избягва се огромен JSON и 500. Timeout 90 сек за cold start. При празна страница: изчакай 1 мин или провери Console за грешки.

## Приложение В. TypeScript типове и интерфейси

Frontend използва типове в types.ts: Item (id, title, description, price, ownerEmail, category, contactEmail, contactPhone, paymentMethod, imageUrl?, isVip), User, Review, Message, ItemOrder, Favorite, View ("login" | "register" | "all" | "mine" | "detail" | "vip" | "favorites" | "orders" | "messages" | "home"). CATEGORIES – константен масив с категориите.

---

*Документацията е съставена по изискванията за софтуерна дипломна работа.*  
*Обем: ~60 страници при форматиране 30 реда × 60 знака (1800 знака/страница), шрифт 12–14 pt, интервал 1,5.*  
*Февруари 2026*
